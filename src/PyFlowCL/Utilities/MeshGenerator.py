# -*- coding: utf-8 -*-
"""
J. Jacobowitz
MacRTL Research Group Notre Dame
Created: 05 March 2023
Last edited: 10 July 2023

MeshGenerator takes a Boundaries object and generates the interior points with
some desired properties. Namely, boundary layers based on user-set wall-normal
spacings. Wall normality for the top and bottom walls is weakly enforced using
the dot product. If no boundary layers are used, then the normality enforcement
via moving boundary points can be used to ensure mesh lines intersect the 
boundaries at nearly right angles.

Note: Functions that begin with an underscore are not meant to be used by the
user. These functions are only intended to be called internally. I.e. the user-
facing functions are the ones without the underscore prefix.

ASSUMPTIONS:
    This code makes some assumptions about what it's given, how the mesh will 
    look, and how the meshing will run. These assumptions are listed below.
    - the mesh has four boundaries: top, bottom, left, and right
    - top and bottom boundaries are functions of x
    - left and right boundaries are functions of y
    - left and right boundaries are close to vertical
    - only boundary layers forming on the top and bottom walls
    - mesh motion is a good proxy for convergence (i.e. if the mesh points 
      don't move more than the tolerance, then the PDEs are satisfied)
    
SHORTCOMINGS
    The current code has some shortcomings/limitations. Keep these in mind when 
    using this mesher.
    - Boundary corners less than 90deg will lead to badly formed mesh elements.
    - Sharply-curved mesh boundary in the mesh are not meshed well.
    - The mesher only works for rectangular-shaped meshes.


TODO -- High Priority:
    - source terms (normality and spacing)
        - issues/bugs
            1. Doesn't work for sharp curves.
            2. Using normality causes it to fail (because of collapses?)
    - **kwargs
        - take mesh settings using kwargs (use dict.get with default values)
        - make a function that lists the mesher parameters and options?
    
TODO -- Low Priority:
    - periodic boundaries
        - make sure the boundary points line up
        - what if the boundaries aren't the same length? require it be true?
    - level set boundaries
    
FUTURE IDEAS:
    - Break class into rectangular and o-type meshing (e.g. for airfoils)
    
Citations:
    - Elliptic PDE for mesh generation:
        Thompson, J. F., Mastin, C. W., and Warsi, Z. U. A., Numerical Grid 
        Generation: Foundations and Applications, North Holland, 1985.
    - Source terms to propogate boundary points' distribution:
        Thomas, P. D., and Middlecoff, J. F., "Direct Control of the Grid Point
        Distribution in Meshes Generated by Elliptic Equations," AIAA Journal, 
        Vol. 18, No. 6, 1980, pp. 652–656. https://doi.org/10.2514/3.50801.
    - mesh move theory:
        C. K.-f. H Hong F Jian-ren, “A numerical method for orthogonal grid 
        generation by laplace system,” Zhejiang University Science A, vol. 1, 
        no. 2, pp. 125–128, Apr. 2000. doi: https://doi.org/10.1007/BF02839228.
    - mesh move tree query:
        https://stackoverflow.com/a/10818976
    - tanh wall function:
        https://www.cfd-online.com/Wiki/Structured_mesh_generation
"""
import numpy as np
import time
import h5py
import matplotlib.pyplot as plt
from scipy.spatial import cKDTree
from scipy.optimize import root  # , newton_krylov
from scipy.signal import convolve2d


class MeshGenerator:
    def __init__(self, boundaries):
        # boundaries object created by the user
        self.boundaries = boundaries

        self.Nx = self.boundaries.Nx
        self.Ny = self.boundaries.Ny

        self.X = np.zeros((self.Nx, self.Ny))
        self.Y = np.zeros((self.Nx, self.Ny))

        # boundary functions
        self.top_func = self.boundaries.top
        self.bottom_func = self.boundaries.bottom
        self.left_func = self.boundaries.left
        self.right_func = self.boundaries.right

        # for selecting a specific edge
        self.top_indx = np.s_[:, -1]
        self.bottom_indx = np.s_[:, 0]
        self.left_indx = np.s_[0, :]
        self.right_indx = np.s_[-1, :]

        self.side_indx = {"top": self.top_indx,
                          "bottom": self.bottom_indx,
                          "left": self.left_indx,
                          "right": self.right_indx}

        # indexing slices (i indexes xi and j indexes eta)
        self.i = self.j = np.s_[1:-1]           # interior (individual)
        self.ij = np.s_[self.i, self.j]         # interior (combined)
        self.ip1 = self.jp1 = np.s_[2:None]     # i+1/j+1
        self.im1 = self.jm1 = np.s_[0:-2]       # i-1/j-1

        # pre-allocation for minor speed improvement when enforcing boundary
        # normal constraint
        self.xy_interior_Nx = np.empty((self.Nx-2, 2))
        self.xy_interior_Ny = np.empty((self.Ny-2, 2))

        # source terms used for wall-normal refinement
        self.Phi = np.zeros((self.Nx-2, self.Ny-2))
        self.Psi = np.zeros((self.Nx-2, self.Ny-2))

    def generate_mesh(self,
                      *,
                      maxiter: int = 10_000,
                      tol: float = 1e-6,
                      verbose: bool = False,
                      moving_boundaries: bool = False,
                      solver: str = "jacobi",
                      layer_thickness_b: float = None,
                      layer_thickness_t: float = None,
                      fine_multiplier: int = 10,
                      dot_product_normality: bool = True,
                      normality_strength = "auto",
                      normality_dist: float = 1/3):
        """Mesh generation interface function that performs the initializations
        and the transfinite meshing followed by the meshing using the chosen 
        method. The user can pass various kwargs to control how the meshing 
        will end up.
        """
        self.maxiter = maxiter
        self.tol = tol
        self.verbose = verbose
        self.moving_boundaries = moving_boundaries

        self.layer_thickness_b = layer_thickness_b
        self.layer_thickness_t = layer_thickness_t
        self.fine_multiplier = fine_multiplier

        self.dot_product_normality = dot_product_normality
        
        if normality_dist > 1/2:
            raise ValueError("MeshGenerator.py: 'normality_dist' should not be"
                             "greater than 1/2.")
        self.normality_dist = normality_dist

        self._initialize_computational_domain()
        self._initialize_boundaries()
        self._initialize_fine()
            
        if self.moving_boundaries and self.tol < self.boundary_min:
            text = (f"Warning: The tolerance {self.tol:.4e} is less than the "
                    f"minimum fine boundary distance {self.boundary_min:.4e}, "
                    "which can prevent convergence when moving boundaries is "
                    "on. Use 'verbose=True' to monitor the 'max move' and "
                    "choose an appropriate 'max_iter' to stop the code early.")
            format_dict = {"Warning":termfrmt.CBLINK+termfrmt.CRED,
                           f"{self.tol:.4e}":termfrmt.CIBOLD,
                           f"{self.boundary_min:.4e}":termfrmt.CIBOLD,
                           "verbose=True":termfrmt.CITALIC,
                           "max move":termfrmt.CITALIC,
                           "max_iter":termfrmt.CITALIC}
            self._formatted_print(text, format_dict)

        self._transfinite()
        
        if self.dot_product_normality:
            if normality_strength == "auto":
                # this calculation seems to give a good result
                # it makes use of the smallest dimension, since the strength
                # should be smaller for smaller geometries
                # as explained in the message, the jacobi solver cannot handle
                # normality strengths as high as the newton-krylov solver, so
                # if the normality is too strong, the value wouldn't need to be
                # decreased as much if the newton-krylov solver is being used 
                # rather than the jacobi solver
                self.normality_strength = 2*5**min([self.X.max() - self.X.min(),
                                                   self.Y.max() - self.Y.min()])
                text = ("--> Using an automatically-determined normality "
                        f"strength equal to {self.normality_strength:.2f}. "
                        "Specify a larger value if normality is not enforced "
                        "strongly enough or specify a smaller value if it is "
                        "too strong. If using the 'jacobi' solver, the "
                        "strength may need to be reduced more than if the "
                        "'newton_krylov' solver is used. Note: The solvers "
                        "can handle a stronger enforcement as the number of "
                        "nodes is increased. ")
                format_dict = {f"{self.normality_strength:.2f}":termfrmt.CIBOLD,
                               "jacobi":termfrmt.CITALIC,
                               "newton_krylov":termfrmt.CITALIC}
                self._formatted_print(text, format_dict)
            elif type(normality_strength) in [float, int]:
                self.normality_strength = normality_strength
            else:
                raise ValueError("MeshGenerator.py: There are no methods "
                                 "implemented to handle normality_strength="
                                 f"{normality_strength}.")

        if self.moving_boundaries and (self.layer_thickness_b is not None
                                       or self.layer_thickness_t is not None):
            text = ("Warning: Moving boundaries and boundary layers do not "
                    "work well together. The code may fail or you may get bad "
                    "results.")
            format_dict = {"Warning":termfrmt.CBLINK+termfrmt.CRED,
                           "fail":termfrmt.CITALIC}
            self._formatted_print(text, format_dict)

        if solver == "jacobi":
            text = "--> Solving using the Jacobi solver."
            format_dict = {"Jacobi":termfrmt.CITALIC}
            self._formatted_print(text, format_dict)
            
            self._solver = self._jacobi
            self.verbose_frequency = 1000
            self.move_frequency = 100
        elif solver == "newton_krylov":
            text = "--> Solving using the Newton-Krylov solver."
            format_dict = {"Newton-Krylov":termfrmt.CITALIC}
            self._formatted_print(text, format_dict)
            # print("Warning: Newton-Krylov solver is experimental and slow.")
            
            self._solver = self._krylov
            self.verbose_frequency = 5
            self.move_frequency = 1

            # preallocate memory
            self.PDE_result = np.zeros((self.Nx, 2*self.Ny))
            self.xy = np.empty((self.Nx, 2*self.Ny))
        else:
            raise ValueError(f"MeshGenerator.py: No mesh solver '{solver}'.")

        self._iterative_solve()

    def plot(self, what: str = "grid", **kwargs: dict):
        """Plotting interface function."""
        if what == "grid":
            return self._grid_plot(**kwargs)
        elif what == "jacobian":
            return self._jacobian_plot(**kwargs)
        elif what == "gradients":
            return self._gradient_plot(**kwargs)
        elif what == "layer_thickness":
            return self._layer_thickness_plot(**kwargs)
        else:
            raise Exception(f"MeshGenerator.py: No plot type '{what}'.")

    def save_grid(self, grid_name: str):
        """Saves the 2D grid to an HDF5 file so it can be imported into the 
        PyFlow solver. The grid can be used using the `Grid.readFromFile` type.
        """
        with h5py.File(grid_name, "w") as f:
            f.create_dataset("Grid0/X",
                             (self.Nx, self.Ny),
                             dtype=np.float64,
                             data=self.X)
            f.create_dataset("Grid0/Y",
                             (self.Nx, self.Ny),
                             dtype=np.float64,
                             data=self.Y)

    def _initialize_computational_domain(self,):
        """Generates xi and eta vectors as well as the Xi and Eta meshgrids.
        Also creates the finite difference constants.
        """
        self.xi = np.linspace(0, 1, self.Nx)
        self.eta = np.linspace(0, 1, self.Ny)
        self.Xi, self.Eta = np.meshgrid(self.xi, self.eta, indexing="ij")

        # xi and eta step sizes
        self.dxi = 1./(self.Nx-1)
        self.deta = 1./(self.Ny-1)

        # first derivative constants
        self.Dxi = 0.5/self.dxi
        self.Deta = 0.5/self.deta

        # second derivative constants
        self.Dxixi = 1./self.dxi**2
        self.Detaeta = 1./self.deta**2
        self.Dxieta = self.Dxi*self.Deta

    def _even_spacing(self, side_range, side_func):
        """Evenly spaces points on a curve by approximately-equal arc lengths 
        using the following procedure:
            1. Finely sample the curve.
            2. Compute the total arc length using the integral arc length
            formula.
            3. Divide the total arc length by the number of segments.
            4. Start at one end iteratively find the next point on the curve
            that is the segment length away using the scipy root finding 
            function.
        """
        N = side_range.size
        xmin = side_range[0]
        xmax = side_range[-1]

        x_fine = np.linspace(xmin, xmax, 10*N)
        y_fine = side_func(x_fine)

        dydx = np.gradient(y_fine, x_fine, edge_order=2)
        L = np.trapz(np.sqrt(1+dydx**2), x_fine)

        ds = L/(N-1)        # how long each segment should be

        def level_set(x, ds, x_prev, y_prev):
            # computes the arc length between the last point and proposed new
            # point; optimization seeks for the arc length to be close to ds
            x_within = np.linspace(x_prev, x[0], 10)
            y_within = side_func(x_within)
            dydx = np.gradient(y_within, x_within, edge_order=2)
            L = np.trapz(np.sqrt(1+dydx**2), x_within)
            return L**2 - ds**2

        x_even = [xmin]
        y_even = [side_func(xmin)]

        # first and last points added manually, only the middle points are
        # optimized
        for _ in range(N-2):
            res = root(level_set, x_even[-1]+ds,
                       args=(ds, x_even[-1], y_even[-1]))
            x_even.append(res.x[0])
            y_even.append(side_func(res.x[0]))

        x_even.append(xmax)
        y_even.append(side_func(xmax))

        return np.array(x_even), np.array(y_even)

    def _find_delta_exp(self, delta, x, ds, L=1.):
        """Exponential spacing helper function that computes the wall-normal 
        spacing (assumes the zeroth point lies on the wall) as part of the 
        optimization routine that finds the best "delta" value that achieves 
        the desired wall-normal spacing.
        """
        s = self._exp_spacing(delta, x, L)
        return np.diff(s)[0] - ds

    def _exp_spacing(self, delta, x, L=1.):
        """given a "delta" value, this function generates the exponential point
        distribution.
        """
        return L*(np.exp(delta*x/L) - 1.)/(np.exp(delta) - 1.)

    def _find_delta_tanh(self, delta, x, ds1, ds2, A, L=1):
        """Hyperbolic tangent spacing helper function that computes the wall-
        normal spacing of both walls as part of the optimization routine that 
        finds the best "delta" value that achieves the desired wall-normal 
        spacings.
        """
        s = self._tanh_spacing(delta, x, A, L)
        ds = np.diff(s)

        return (ds[0] - ds1)**2 + (ds[-1] - ds2)**2

    def _tanh_spacing(self, delta, x, A, L=1):
        """Given a "delta" value, this function generates the hyperbolic 
        tangent point distribution.

        see: https://www.cfd-online.com/Wiki/Structured_mesh_generation
        """
        u = 0.5*(1. + np.tanh(delta*(x/L - 0.5))/np.tanh(0.5*delta))
        return L*u/(A+(1-A)*u)

    def _generate_boundary(self, side, side_range, side_func, delta=None):
        """Generates the boundary for the selected side. If it is the top or
        bottom, an even spacing is used (equal arc length between points). For
        the sides, it depends on whether wall spacing was set. If no wall 
        spacing, then the even spacing is used. If only one wall spacing, then
        exponential for the top or bottom (depending on which side the spacing
        was set for). If both sides have wall spacing, then the tanh spacing
        is used.

        The exponential and tanh spacing methods use optimization routines to 
        find the "delta" value.        
        """
        def layer_spacing_error(side, ds, dy):
            return (f"MeshGenerator.py: Minimum {side} layer spacing for the "
                    f"given settings is {dy:.3e} but {side} layer spacing of "
                    f"{ds:.3e} was given.")
        # Top and bottom use even spacing
        if side in ["top", "bottom"]:
            x, y = self._even_spacing(side_range, side_func)
            return x, y, None

        # No wall spacing if the layer thicknesses are not set (i.e. None)
        elif not self.layer_thickness_b and not self.layer_thickness_t:
            y, x = self._even_spacing(side_range, side_func)
            return x, y, None

        L = side_range[-1] - side_range[0]      # assumes a straight side
        yshifted, dy = np.linspace(0, L, self.Ny, retstep=True)

        # Choses exponential (top or bottom) depending on which wall spacing
        # is set. If both, then it uses the tanh spacing.
        if self.layer_thickness_b and not self.layer_thickness_t:
            ds = self.layer_thickness_b
            if ds > dy:
                raise ValueError(layer_spacing_error("first", ds, dy))

            if not delta:
                sol = root(self._find_delta_exp, 1, args=(yshifted, ds, L))
                delta = sol.x

            y = self._exp_spacing(delta, yshifted, L) + side_range[0]
        elif self.layer_thickness_t and not self.layer_thickness_b:
            ds = self.layer_thickness_t
            if ds > dy:
                raise ValueError(layer_spacing_error("last", ds, dy))

            if not delta:
                sol = root(self._find_delta_exp, 1, args=(yshifted, ds, L))
                delta = sol.x

            # The exponential function always makes the smallest points at
            # the beginning (smaller y), so it is reversed if the boundary
            # layer is at the top instead of the bottom.
            y = (side_range[-1] - self._exp_spacing(delta, yshifted, L))[::-1]
        else:
            ds1 = self.layer_thickness_b
            ds2 = self.layer_thickness_t
            if ds1 > dy:
                raise ValueError(layer_spacing_error("first", ds1, dy))
            if ds2 > dy:
                raise ValueError(layer_spacing_error("last", ds2, dy))

            A = np.sqrt(ds2/ds1)

            if not delta:
                sol = root(self._find_delta_tanh, 0.5,
                           args=(yshifted, ds1, ds2, A, L))
                delta = sol.x[0]

            y = self._tanh_spacing(delta, yshifted, A, L) + side_range[0]

        return side_func(y), y, delta

    def _initialize_boundaries(self,):
        """Interface function that calls the boundary generator for each of the
        sides.
        """
        # top
        top_range = np.linspace(*self.boundaries.top_range, self.Nx)
        tmp = self._generate_boundary("top", top_range, self.top_func)
        self.X[self.top_indx], self.Y[self.top_indx], _ = tmp

        # bottom
        bottom_range = np.linspace(*self.boundaries.bottom_range, self.Nx)
        tmp = self._generate_boundary("bottom", bottom_range, self.bottom_func)
        self.X[self.bottom_indx], self.Y[self.bottom_indx], _ = tmp

        # left
        left_range = np.linspace(*self.boundaries.left_range, self.Ny)
        tmp = self._generate_boundary("left", left_range, self.left_func)
        self.X[self.left_indx], self.Y[self.left_indx], self.left_delta = tmp

        # right
        right_range = np.linspace(*self.boundaries.right_range, self.Ny)
        tmp = self._generate_boundary("right", right_range, self.right_func)
        self.X[self.right_indx], self.Y[self.right_indx], self.right_delta = tmp

    def _initialize_fine(self,):
        """Generates the finely sampled boudnaries for boundary mesh point
        moving to enforce normality. For the top and bottom, there is no
        change, but for the left and right, it uses the "delta" value computed
        and saved in the initialize boundaries function.

        This function also creates the KDTrees to be used for the normality 
        function. The KDTrees do not include the corner points because those
        cannot be chosen anyways (choosing those points would mean that two
        points are collapsing into one since an edge point will now be a 
        corner).
        """
        # top
        top_fine = np.linspace(*self.boundaries.top_range,
                               self.fine_multiplier*self.Nx)
        tmp = self._generate_boundary("top",
                                      top_fine,
                                      self.top_func)
        self.xfine_top, self.yfine_top, _ = tmp

        # bottom
        bottom_fine = np.linspace(*self.boundaries.bottom_range,
                                  self.fine_multiplier*self.Nx)
        tmp = self._generate_boundary("bottom",
                                      bottom_fine,
                                      self.bottom_func)
        self.xfine_bottom, self.yfine_bottom, _ = tmp

        # left
        left_fine = np.linspace(*self.boundaries.left_range,
                                self.fine_multiplier*self.Ny)
        tmp = self._generate_boundary("left",
                                      left_fine,
                                      self.left_func,
                                      self.left_delta)
        self.xfine_left, self.yfine_left, _ = tmp

        # right
        right_fine = np.linspace(*self.boundaries.right_range,
                                 self.fine_multiplier*self.Ny)
        tmp = self._generate_boundary("right",
                                      right_fine,
                                      self.right_func,
                                      self.right_delta)
        self.xfine_right, self.yfine_right, _ = tmp

        # only use interior points so the corners are not selected (which
        # would mean the corner element has a collapsed edge)
        self.xfine_top = self.xfine_top[1:-1]
        self.yfine_top = self.yfine_top[1:-1]
        self.xfine_bottom = self.xfine_bottom[1:-1]
        self.yfine_bottom = self.yfine_bottom[1:-1]
        self.xfine_left = self.xfine_left[1:-1]
        self.yfine_left = self.yfine_left[1:-1]
        self.xfine_right = self.xfine_right[1:-1]
        self.yfine_right = self.yfine_right[1:-1]

        self.tree_t = cKDTree(np.c_[self.xfine_top, self.yfine_top])
        self.tree_b = cKDTree(np.c_[self.xfine_bottom, self.yfine_bottom])
        self.tree_l = cKDTree(np.c_[self.xfine_left, self.yfine_left])
        self.tree_r = cKDTree(np.c_[self.xfine_right, self.yfine_right])

        # finding the smallest distance between boundary points
        # if moving_boundaries, it is possible that the solver will be stuck
        # moving points back and forth and not converge if the tolerance is
        # smaller than the smallest distance between points
        dist_t = np.sqrt(np.diff(self.xfine_top)**2
                         + np.diff(self.yfine_top)**2)
        dist_b = np.sqrt(np.diff(self.xfine_bottom)**2
                         + np.diff(self.yfine_bottom)**2)
        dist_l = np.sqrt(np.diff(self.xfine_left)**2
                         + np.diff(self.yfine_left)**2)
        dist_r = np.sqrt(np.diff(self.xfine_right)**2
                         + np.diff(self.yfine_right)**2)

        self.boundary_min = min([dist_t.min(),
                                 dist_b.min(),
                                 dist_l.min(),
                                 dist_r.min()])
        
        self.original_idxs = {"top": np.searchsorted(self.xfine_top,
                                                     self.X[self.top_indx][self.j]),
                              "bottom": np.searchsorted(self.xfine_bottom,
                                                        self.X[self.bottom_indx][self.j]),
                              "left": np.searchsorted(self.yfine_left,
                                                      self.Y[self.left_indx][self.j]),
                              "right": np.searchsorted(self.yfine_right,
                                                       self.Y[self.right_indx][self.j])}


    def _transfinite(self,):
        """Performs transfinite interpolation for the interior points based on
        the boundary since this is a fast way to get good guesses for the 
        interior points.
        """
        I, J = np.meshgrid(np.arange(1, self.Nx-1),
                           np.arange(1, self.Ny-1),
                           indexing="ij")

        M = self.Nx-1
        N = self.Ny-1

        M_inv = 1/M
        N_inv = 1/N
        MN_inv = M_inv*N_inv

        I, J = np.meshgrid(np.arange(1, M), np.arange(1, N), indexing="ij")

        self.X[self.ij] = (I*self.X[-1:, 1:-1]*M_inv
                           + (M-I)*self.X[0:1, 1:-1]*M_inv
                           + J*self.X[1:-1, -1:]*N_inv
                           + (N-J)*self.X[1:-1, 0:1]*N_inv
                           - I*J*self.X[-1:, -1:]*MN_inv
                           - I*(N-J)*self.X[-1:, 0:1]*MN_inv
                           - (M-I)*J*self.X[0:1, -1:]*MN_inv
                           - (M-I)*(N-J)*self.X[0:1, 0:1]*MN_inv
                           )

        self.Y[self.ij] = (I*self.Y[-1:, 1:-1]*M_inv
                           + (M-I)*self.Y[0:1, 1:-1]*M_inv
                           + J*self.Y[1:-1, -1:]*N_inv
                           + (N-J)*self.Y[1:-1, 0:1]*N_inv
                           - I*J*self.Y[-1:, -1:]*MN_inv
                           - I*(N-J)*self.Y[-1:, 0:1]*MN_inv
                           - (M-I)*J*self.Y[0:1, -1:]*MN_inv
                           - (M-I)*(N-J)*self.Y[0:1, 0:1]*MN_inv
                           )

    def _compute_first_derivatives_faster(self,
                                          convolve=False,
                                          boundary=True,
                                          interior=True):
        """Uses finite difference to compute the second-order first derivatives
        for x and y points in the xi and eta directions. Interior points use
        central differences while boundary points use one-sided differences. By
        default, all the derivatives are computed, but only the boundary or
        interior points can be computed using the optional kwargs. If only the
        interior points are computed, the return will strip off the edges.

        Convolve: performs a convolution to find the average value in a cell
        based on the corner values.

        This method is faster than the np.gradient method. I think it is 
        because it doesn't compute more than is necessary. I.e. if interior
        is False, then it just won't compute anything in the interior.
        """
        # compute edge derivatives using stencil for 2nd order, one-sided
        # 1st derivatives
        c0 = 1.5
        c1 = 2
        c2 = 0.5

        # xi derivatives
        X_xi = np.ones_like(self.X)
        if interior:
            X_xi[self.ij] = self.Dxi*(self.X[self.ip1, self.j]
                                      - self.X[self.im1, self.j])
        if boundary:
            # top (without corners)
            X_xi[self.i, -1] = self.Dxi*(self.X[self.ip1, -1]
                                         - self.X[self.im1, -1])
            # bottom (without corners)
            X_xi[self.i, 0] = self.Dxi*(self.X[self.ip1, 0]
                                        - self.X[self.im1, 0])
            # left (with corners)
            X_xi[0, :] = 2*self.Dxi*(-c0*self.X[0, :]
                                     + c1*self.X[1, :]
                                     - c2*self.X[2, :])
            # right (with corners)
            X_xi[-1, :] = 2*self.Dxi*(c0*self.X[-1, :]
                                      - c1*self.X[-2, :]
                                      + c2*self.X[-3, :])

        Y_xi = np.ones_like(self.Y)
        if interior:
            Y_xi[self.ij] = self.Dxi*(self.Y[self.ip1, self.j]
                                      - self.Y[self.im1, self.j])
        if boundary:
            # top (without corners)
            Y_xi[self.i, -1] = self.Dxi*(self.Y[self.ip1, -1]
                                         - self.Y[self.im1, -1])
            # bottom (without corners)
            Y_xi[self.i, 0] = self.Dxi*(self.Y[self.ip1, 0]
                                        - self.Y[self.im1, 0])
            # left (with corners)
            Y_xi[0, :] = 2*self.Dxi*(-c0*self.Y[0, :]
                                     + c1*self.Y[1, :]
                                     - c2*self.Y[2, :])
            # right (with corners)
            Y_xi[-1, :] = 2*self.Dxi*(c0*self.Y[-1, :]
                                      - c1*self.Y[-2, :]
                                      + c2*self.Y[-3, :])

        # eta derivatives
        X_eta = np.ones_like(self.X)
        if interior:
            X_eta[self.ij] = self.Deta*(self.X[self.i, self.jp1]
                                        - self.X[self.i, self.jm1])
        if boundary:
            # top (with corners)
            X_eta[:, -1] = 2*self.Deta*(c0*self.X[:, -1]
                                        - c1*self.X[:, -2]
                                        + c2*self.X[:, -3])
            # bottom (with corners)
            X_eta[:, 0] = 2*self.Deta*(-c0*self.X[:, 0]
                                       + c1*self.X[:, 1]
                                       - c2*self.X[:, 2])
            # left (without corners)
            X_eta[0, self.j] = self.Deta*(self.X[0, self.jp1]
                                          - self.X[0, self.jm1])
            # right (without corners)
            X_eta[-1, self.j] = self.Deta*(self.X[-1, self.jp1]
                                           - self.X[-1, self.jm1])

        Y_eta = np.ones_like(self.Y)
        if interior:
            Y_eta[self.ij] = self.Deta*(self.Y[self.i, self.jp1]
                                        - self.Y[self.i, self.jm1])
        if boundary:
            # top (with corners)
            Y_eta[:, -1] = 2*self.Deta*(c0*self.Y[:, -1]
                                        - c1*self.Y[:, -2]
                                        + c2*self.Y[:, -3])
            # bottom (with corners)
            Y_eta[:, 0] = 2*self.Deta*(-c0*self.Y[:, 0]
                                       + c1*self.Y[:, 1]
                                       - c2*self.Y[:, 2])
            # left (without corners)
            Y_eta[0, self.j] = self.Deta*(self.Y[0, self.jp1]
                                          - self.Y[0, self.jm1])
            # right (without corners)
            Y_eta[-1, self.j] = self.Deta*(self.Y[-1, self.jp1]
                                           - self.Y[-1, self.jm1])

        # average cell corners to get cell center
        if convolve:
            k = 0.25*np.ones((2, 2))
            X_xi = convolve2d(X_xi, k)[self.ij]
            Y_xi = convolve2d(Y_xi, k)[self.ij]
            X_eta = convolve2d(X_eta, k)[self.ij]
            Y_eta = convolve2d(Y_eta, k)[self.ij]

        if not boundary:
            X_xi = X_xi[self.ij]
            Y_xi = Y_xi[self.ij]
            X_eta = X_eta[self.ij]
            Y_eta = Y_eta[self.ij]

        return X_xi, Y_xi, X_eta, Y_eta

    def _compute_first_derivatives(self,
                                   convolve=False,
                                   boundary=True,
                                   interior=True):
        """Uses finite difference to compute the second-order first derivatives
        for x and y points in the xi and eta directions. Interior points use
        central differences while boundary points use one-sided differences. By
        default, all the derivatives are computed, but only the boundary or
        interior points can be computed using the optional kwargs. If only the
        interior points are computed, the return will strip off the edges.

        Convolve: performs a convolution to find the average value in a cell
        based on the corner values.        
        """
        X_xi = np.gradient(self.X, self.dxi, axis=0, edge_order=2)
        Y_xi = np.gradient(self.Y, self.dxi, axis=0, edge_order=2)
        X_eta = np.gradient(self.X, self.deta, axis=1, edge_order=2)
        Y_eta = np.gradient(self.Y, self.deta, axis=1, edge_order=2)

        # average cell corners to get cell center
        if convolve:
            k = 0.25*np.ones((2, 2))
            X_xi = convolve2d(X_xi, k)[self.ij]
            Y_xi = convolve2d(Y_xi, k)[self.ij]
            X_eta = convolve2d(X_eta, k)[self.ij]
            Y_eta = convolve2d(Y_eta, k)[self.ij]

        if not interior:
            X_xi[self.ij] = 1.
            Y_xi[self.ij] = 1.
            X_eta[self.ij] = 1.
            Y_eta[self.ij] = 1.

        if not boundary:
            X_xi = X_xi[self.ij]
            Y_xi = Y_xi[self.ij]
            X_eta = X_eta[self.ij]
            Y_eta = Y_eta[self.ij]

        return X_xi, Y_xi, X_eta, Y_eta

    def _compute_second_derivatives_faster(self,
                                           boundary=True,
                                           interior=True,
                                           modified=False):
        """Uses finite difference to compute the second-order second 
        derivatives for x and y points in the xi and eta directions. Interior 
        points use central differences while boundary points use one-sided 
        differences. By default, all the derivatives are computed, but only the 
        boundary or interior points can be computed using the optional kwargs. 
        If only the interior points are computed, the return will strip off the 
        edges.

        Modified: For the jacobi method, we need a modified second derivative
        that does not include the term at point ij, since this is on the LHS
        of the equation. So, this optional kwarg will remove that term from
        the derivatives that have it.         

        This method is faster than the np.gradient method. I think it is 
        because it doesn't compute more than is necessary. I.e. if interior
        is False, then it just won't compute anything in the interior.
        """
        # if modified, remove the ij terms in the xixi and etaeta derivatives
        # by multiplying those terms by 0
        # modifier = 1. if not modified else 0.
        modifier = not modified

        # compute edge derivatives using stencil for 2nd order, one-sided
        # 2nd derivatives
        c0 = 2
        c1 = -5
        c2 = 4
        c3 = -1

        # xi-xi derivatives
        X_xixi = np.ones_like(self.X)
        if interior:
            X_xixi[self.ij] = self.Dxixi*(self.X[self.ip1, self.j]
                                          - modifier*2*self.X[self.ij]
                                          + self.X[self.im1, self.j])
        if boundary:
            X_xixi[self.i, -1] = self.Dxixi*(self.X[self.ip1, -1]
                                             - 2*self.X[self.i, -1]
                                             + self.X[self.im1, -1])
            X_xixi[self.i, 0] = self.Dxixi*(self.X[self.ip1, 0]
                                            - 2*self.X[self.i, 0]
                                            + self.X[self.im1, 0])
            X_xixi[0, :] = self.Dxixi*(c0*self.X[0, :]
                                       + c1*self.X[1, :]
                                       + c2*self.X[2, :]
                                       + c3*self.X[3, :])
            X_xixi[-1, :] = self.Dxixi*(c0*self.X[-1, :]
                                        + c1*self.X[-2, :]
                                        + c2*self.X[-3, :]
                                        + c3*self.X[-4, :])

        Y_xixi = np.ones_like(self.Y)
        if interior:
            Y_xixi[self.ij] = self.Dxixi*(self.Y[self.ip1, self.j]
                                          - modifier*2*self.Y[self.ij]
                                          + self.Y[self.im1, self.j])
        if boundary:
            Y_xixi[self.i, -1] = self.Dxixi*(self.Y[self.ip1, -1]
                                             - 2*self.Y[self.i, -1]
                                             + self.Y[self.im1, -1])
            Y_xixi[self.i, 0] = self.Dxixi*(self.Y[self.ip1, 0]
                                            - 2*self.Y[self.i, 0]
                                            + self.Y[self.im1, 0])
            Y_xixi[0, :] = self.Dxixi*(c0*self.Y[0, :]
                                       + c1*self.Y[1, :]
                                       + c2*self.Y[2, :]
                                       + c3*self.Y[3, :])
            Y_xixi[-1, :] = self.Dxixi*(c0*self.Y[-1, :]
                                        + c1*self.Y[-2, :]
                                        + c2*self.Y[-3, :]
                                        + c3*self.Y[-4, :])

        # eta-eta derivatives
        X_etaeta = np.ones_like(self.X)
        if interior:
            X_etaeta[self.ij] = self.Detaeta*(self.X[self.i, self.jp1]
                                              - modifier*2*self.X[self.ij]
                                              + self.X[self.i, self.jm1])
        if boundary:
            X_etaeta[:, -1] = self.Detaeta*(c0*self.X[:, -1]
                                            + c1*self.X[:, -2]
                                            + c2*self.X[:, -3]
                                            + c3*self.X[:, -4])
            X_etaeta[:, 0] = self.Detaeta*(c0*self.X[:, 0]
                                           + c1*self.X[:, 1]
                                           + c2*self.X[:, 2]
                                           + c3*self.X[:, 3])
            X_etaeta[0, self.j] = self.Detaeta*(self.X[0, self.jp1]
                                                - 2*self.X[0, self.j]
                                                + self.X[0, self.jm1])
            X_etaeta[-1, self.j] = self.Detaeta*(self.X[-1, self.jp1]
                                                 - 2*self.X[-1, self.j]
                                                 + self.X[-1, self.jm1])

        Y_etaeta = np.ones_like(self.Y)
        if interior:
            Y_etaeta[self.ij] = self.Detaeta*(self.Y[self.i, self.jp1]
                                              - modifier*2*self.Y[self.ij]
                                              + self.Y[self.i, self.jm1])
        if boundary:
            Y_etaeta[:, -1] = self.Detaeta*(c0*self.Y[:, -1]
                                            + c1*self.Y[:, -2]
                                            + c2*self.Y[:, -3]
                                            + c3*self.Y[:, -4])
            Y_etaeta[:, 0] = self.Detaeta*(c0*self.Y[:, 0]
                                           + c1*self.Y[:, 1]
                                           + c2*self.Y[:, 2]
                                           + c3*self.Y[:, 3])
            Y_etaeta[0, self.j] = self.Detaeta*(self.Y[0, self.jp1]
                                                - 2*self.Y[0, self.j]
                                                + self.Y[0, self.jm1])
            Y_etaeta[-1, self.j] = self.Detaeta*(self.Y[-1, self.jp1]
                                                 - 2*self.Y[-1, self.j]
                                                 + self.Y[-1, self.jm1])

        # xi-eta second derivatives
        # TODO -- verify these are correct
        d0 = 1.5
        d1 = 2
        d2 = 0.5
        X_xieta = np.ones_like(self.X)
        if interior:
            X_xieta[self.ij] = self.Dxieta*(self.X[self.ip1, self.jp1]
                                            - self.X[self.ip1, self.jm1]
                                            - self.X[self.im1, self.jp1]
                                            + self.X[self.im1, self.jm1])
        if boundary:
            # top (without corners)
            X_xieta[self.i, -1] = 2*self.Dxieta*(d0*(self.X[self.ip1, -1]
                                                     - self.X[self.im1, -1])
                                                 - d1*(self.X[self.ip1, -2]
                                                       - self.X[self.im1, -2])
                                                 + d2*(self.X[self.ip1, -3]
                                                       - self.X[self.im1, -3]))
            # bottom (without corners)
            X_xieta[self.i, 0] = 2*self.Dxieta*(-d0*(self.X[self.ip1, 0]
                                                     - self.X[self.im1, 0])
                                                + d1*(self.X[self.ip1, 1]
                                                      - self.X[self.im1, 1])
                                                - d2*(self.X[self.ip1, 2]
                                                      - self.X[self.im1, 2]))
            # left (without corners)
            X_xieta[0, self.j] = 2*self.Dxieta*(-d0*(self.X[0, self.jp1]
                                                     - self.X[0, self.jm1])
                                                + d1*(self.X[1, self.jp1]
                                                      - self.X[1, self.jm1])
                                                - d2*(self.X[2, self.jp1]
                                                      - self.X[2, self.jm1]))
            # right (without corners)
            X_xieta[-1, self.j] = 2*self.Dxieta*(d0*(self.X[-1, self.jp1]
                                                     - self.X[-1, self.jm1])
                                                 - d1*(self.X[-2, self.jp1]
                                                       - self.X[-2, self.jm1])
                                                 + d2*(self.X[-3, self.jp1]
                                                       - self.X[-3, self.jm1]))
            # top right corner
            X_xieta[-1, -1] = 4*self.Dxieta*(d0*(d0*self.X[-1, -1]
                                                 - d1*self.X[-1, -2]
                                                 + d2*self.X[-1, -3])
                                             - d1*(d0*self.X[-2, -1]
                                                   - d1*self.X[-2, -2]
                                                   + d2*self.X[-2, -3])
                                             + d2*(d0*self.X[-3, -1]
                                                   - d1*self.X[-3, -2]
                                                   + d2*self.X[-3, -3]))
            # top left corner
            X_xieta[0, -1] = 4*self.Dxieta*(-d0*(d0*self.X[0, -1]
                                                 - d1*self.X[0, -2]
                                                 + d2*self.X[0, -3])
                                            + d1*(d0*self.X[1, -1]
                                                  - d1*self.X[1, -2]
                                                  + d2*self.X[1, -3])
                                            - d2*(d0*self.X[2, -1]
                                                  - d1*self.X[2, -2]
                                                  + d2*self.X[2, -3]))
            # bottom left corner
            X_xieta[0, 0] = 4*self.Dxieta*(-d0*(-d0*self.X[0, 0]
                                                + d1*self.X[0, 1]
                                                - d2*self.X[0, 2])
                                           + d1*(-d0*self.X[1, 0]
                                                 + d1*self.X[1, 1]
                                                 - d2*self.X[1, 2])
                                           - d2*(-d0*self.X[2, 0]
                                                 + d1*self.X[2, 1]
                                                 - d2*self.X[2, 2]))
            # bottom right corner
            X_xieta[-1, 0] = 4*self.Dxieta*(d0*(-d0*self.X[-1, 0]
                                                + d1*self.X[-1, 1]
                                                - d2*self.X[-1, 2])
                                            - d1*(-d0*self.X[-2, 0]
                                                  + d1*self.X[-2, 1]
                                                  - d2*self.X[-2, 2])
                                            + d2*(-d0*self.X[-3, 0]
                                                  + d1*self.X[-3, 1]
                                                  - d2*self.X[-3, 2]))

        Y_xieta = np.ones_like(self.Y)
        if interior:
            Y_xieta[self.ij] = self.Dxieta*(self.Y[self.ip1, self.jp1]
                                            - self.Y[self.ip1, self.jm1]
                                            - self.Y[self.im1, self.jp1]
                                            + self.Y[self.im1, self.jm1])
        if boundary:
            d0 = 1.5
            d1 = 2
            d2 = 0.5
            # top (without corners)
            Y_xieta[self.i, -1] = 2*self.Dxieta*(d0*(self.Y[self.ip1, -1]
                                                     - self.Y[self.im1, -1])
                                                 - d1*(self.Y[self.ip1, -2]
                                                       - self.Y[self.im1, -2])
                                                 + d2*(self.Y[self.ip1, -3]
                                                       - self.Y[self.im1, -3]))
            # bottom (without corners)
            Y_xieta[self.i, 0] = 2*self.Dxieta*(-d0*(self.Y[self.ip1, 0]
                                                     - self.Y[self.im1, 0])
                                                + d1*(self.Y[self.ip1, 1]
                                                      - self.Y[self.im1, 1])
                                                - d2*(self.Y[self.ip1, 2]
                                                      - self.Y[self.im1, 2]))
            # left (without corners)
            Y_xieta[0, self.j] = 2*self.Dxieta*(-d0*(self.Y[0, self.jp1]
                                                     - self.Y[0, self.jm1])
                                                + d1*(self.Y[1, self.jp1]
                                                      - self.Y[1, self.jm1])
                                                - d2*(self.Y[2, self.jp1]
                                                      - self.Y[2, self.jm1]))
            # right (without corners)
            Y_xieta[-1, self.j] = 2*self.Dxieta*(d0*(self.Y[-1, self.jp1]
                                                     - self.Y[-1, self.jm1])
                                                 - d1*(self.Y[-2, self.jp1]
                                                       - self.Y[-2, self.jm1])
                                                 + d2*(self.Y[-3, self.jp1]
                                                       - self.Y[-3, self.jm1]))
            # top right corner
            Y_xieta[-1, -1] = 4*self.Dxieta*(d0*(d0*self.Y[-1, -1]
                                                 - d1*self.Y[-1, -2]
                                                 + d2*self.Y[-1, -3])
                                             - d1*(d0*self.Y[-2, -1]
                                                   - d1*self.Y[-2, -2]
                                                   + d2*self.Y[-2, -3])
                                             + d2*(d0*self.Y[-3, -1]
                                                   - d1*self.Y[-3, -2]
                                                   + d2*self.Y[-3, -3]))
            # top left corner
            Y_xieta[0, -1] = 4*self.Dxieta*(-d0*(d0*self.Y[0, -1]
                                                 - d1*self.Y[0, -2]
                                                 + d2*self.Y[0, -3])
                                            + d1*(d0*self.Y[1, -1]
                                                  - d1*self.Y[1, -2]
                                                  + d2*self.Y[1, -3])
                                            - d2*(d0*self.Y[2, -1]
                                                  - d1*self.Y[2, -2]
                                                  + d2*self.Y[2, -3]))
            # bottom left corner
            Y_xieta[0, 0] = 4*self.Dxieta*(-d0*(-d0*self.Y[0, 0]
                                                + d1*self.Y[0, 1]
                                                - d2*self.Y[0, 2])
                                           + d1*(-d0*self.Y[1, 0]
                                                 + d1*self.Y[1, 1]
                                                 - d2*self.Y[1, 2])
                                           - d2*(-d0*self.Y[2, 0]
                                                 + d1*self.Y[2, 1]
                                                 - d2*self.Y[2, 2]))
            # bottom right corner
            Y_xieta[-1, 0] = 4*self.Dxieta*(d0*(-d0*self.Y[-1, 0]
                                                + d1*self.Y[-1, 1]
                                                - d2*self.Y[-1, 2])
                                            - d1*(-d0*self.Y[-2, 0]
                                                  + d1*self.Y[-2, 1]
                                                  - d2*self.Y[-2, 2])
                                            + d2*(-d0*self.Y[-3, 0]
                                                  + d1*self.Y[-3, 1]
                                                  - d2*self.Y[-3, 2]))

        if not boundary:
            X_xixi = X_xixi[self.ij]
            Y_xixi = Y_xixi[self.ij]
            X_etaeta = X_etaeta[self.ij]
            Y_etaeta = Y_etaeta[self.ij]
            X_xieta = X_xieta[self.ij]
            Y_xieta = Y_xieta[self.ij]

        return X_xixi, Y_xixi, X_etaeta, Y_etaeta, X_xieta, Y_xieta

    def _compute_second_derivatives(self,
                                    boundary=True,
                                    interior=True,
                                    modified=False):
        """Uses finite difference to compute the second-order second 
        derivatives for x and y points in the xi and eta directions. Interior 
        points use central differences while boundary points use one-sided 
        differences. By default, all the derivatives are computed, but only the 
        boundary or interior points can be computed using the optional kwargs. 
        If only the interior points are computed, the return will strip off the 
        edges.

        Modified: For the jacobi method, we need a modified second derivative
        that does not include the term at point ij, since this is on the LHS
        of the equation. So, this optional kwarg will remove that term from
        the derivatives that have it.         
        """
        # compute edge derivatives using stencil for 2nd order, one-sided
        # 2nd derivatives
        c0 = 2
        c1 = -5
        c2 = 4
        c3 = -1

        # xi-xi derivatives
        X_xixi = np.ones_like(self.X)
        if interior:
            X_xixi[self.ij] = self.Dxixi*(self.X[self.ip1, self.j]
                                          - 2*self.X[self.ij]
                                          + self.X[self.im1, self.j])
        if boundary:
            X_xixi[self.i, -1] = self.Dxixi*(self.X[self.ip1, -1]
                                             - 2*self.X[self.i, -1]
                                             + self.X[self.im1, -1])
            X_xixi[self.i, 0] = self.Dxixi*(self.X[self.ip1, 0]
                                            - 2*self.X[self.i, 0]
                                            + self.X[self.im1, 0])
            X_xixi[0, :] = self.Dxixi*(c0*self.X[0, :]
                                       + c1*self.X[1, :]
                                       + c2*self.X[2, :]
                                       + c3*self.X[3, :])
            X_xixi[-1, :] = self.Dxixi*(c0*self.X[-1, :]
                                        + c1*self.X[-2, :]
                                        + c2*self.X[-3, :]
                                        + c3*self.X[-4, :])

        Y_xixi = np.ones_like(self.Y)
        if interior:
            Y_xixi[self.ij] = self.Dxixi*(self.Y[self.ip1, self.j]
                                          - 2*self.Y[self.ij]
                                          + self.Y[self.im1, self.j])
        if boundary:
            Y_xixi[self.i, -1] = self.Dxixi*(self.Y[self.ip1, -1]
                                             - 2*self.Y[self.i, -1]
                                             + self.Y[self.im1, -1])
            Y_xixi[self.i, 0] = self.Dxixi*(self.Y[self.ip1, 0]
                                            - 2*self.Y[self.i, 0]
                                            + self.Y[self.im1, 0])
            Y_xixi[0, :] = self.Dxixi*(c0*self.Y[0, :]
                                       + c1*self.Y[1, :]
                                       + c2*self.Y[2, :]
                                       + c3*self.Y[3, :])
            Y_xixi[-1, :] = self.Dxixi*(c0*self.Y[-1, :]
                                        + c1*self.Y[-2, :]
                                        + c2*self.Y[-3, :]
                                        + c3*self.Y[-4, :])

        # eta-eta derivatives
        X_etaeta = np.ones_like(self.X)
        if interior:
            X_etaeta[self.ij] = self.Detaeta*(self.X[self.i, self.jp1]
                                              - 2*self.X[self.ij]
                                              + self.X[self.i, self.jm1])
        if boundary:
            X_etaeta[:, -1] = self.Detaeta*(c0*self.X[:, -1]
                                            + c1*self.X[:, -2]
                                            + c2*self.X[:, -3]
                                            + c3*self.X[:, -4])
            X_etaeta[:, 0] = self.Detaeta*(c0*self.X[:, 0]
                                           + c1*self.X[:, 1]
                                           + c2*self.X[:, 2]
                                           + c3*self.X[:, 3])
            X_etaeta[0, self.j] = self.Detaeta*(self.X[0, self.jp1]
                                                - 2*self.X[0, self.j]
                                                + self.X[0, self.jm1])
            X_etaeta[-1, self.j] = self.Detaeta*(self.X[-1, self.jp1]
                                                 - 2*self.X[-1, self.j]
                                                 + self.X[-1, self.jm1])

        Y_etaeta = np.ones_like(self.Y)
        if interior:
            Y_etaeta[self.ij] = self.Detaeta*(self.Y[self.i, self.jp1]
                                              - 2*self.Y[self.ij]
                                              + self.Y[self.i, self.jm1])
        if boundary:
            Y_etaeta[:, -1] = self.Detaeta*(c0*self.Y[:, -1]
                                            + c1*self.Y[:, -2]
                                            + c2*self.Y[:, -3]
                                            + c3*self.Y[:, -4])
            Y_etaeta[:, 0] = self.Detaeta*(c0*self.Y[:, 0]
                                           + c1*self.Y[:, 1]
                                           + c2*self.Y[:, 2]
                                           + c3*self.Y[:, 3])
            Y_etaeta[0, self.j] = self.Detaeta*(self.Y[0, self.jp1]
                                                - 2*self.Y[0, self.j]
                                                + self.Y[0, self.jm1])
            Y_etaeta[-1, self.j] = self.Detaeta*(self.Y[-1, self.jp1]
                                                 - 2*self.Y[-1, self.j]
                                                 + self.Y[-1, self.jm1])

        # xi-eta second derivatives
        # The cross derivatives can be computed using successive application
        # of the first derivatives.
        X_xi, Y_xi, _, _ = self._compute_first_derivatives()
        X_xieta = np.gradient(X_xi, self.deta, axis=1, edge_order=2)
        Y_xieta = np.gradient(Y_xi, self.deta, axis=1, edge_order=2)

        # if modified, remove the ij terms in the xixi and etaeta derivatives
        if modified and interior:
            X_xixi[self.ij] = self.Dxixi*(self.X[self.ip1, self.j]
                                          + self.X[self.im1, self.j])
            Y_xixi[self.ij] = self.Dxixi*(self.Y[self.ip1, self.j]
                                          + self.Y[self.im1, self.j])
            X_etaeta[self.ij] = self.Detaeta*(self.X[self.i, self.jp1]
                                              + self.X[self.i, self.jm1])
            Y_etaeta[self.ij] = self.Detaeta*(self.Y[self.i, self.jp1]
                                              + self.Y[self.i, self.jm1])

        if not interior:
            X_xixi[self.ij] = 1.
            Y_xixi[self.ij] = 1.
            X_etaeta[self.ij] = 1.
            Y_etaeta[self.ij] = 1.
            X_xieta[self.ij] = 1.
            Y_xieta[self.ij] = 1.

        if not boundary:
            X_xixi = X_xixi[self.ij]
            Y_xixi = Y_xixi[self.ij]
            X_etaeta = X_etaeta[self.ij]
            Y_etaeta = Y_etaeta[self.ij]
            X_xieta = X_xieta[self.ij]
            Y_xieta = Y_xieta[self.ij]

        return X_xixi, Y_xixi, X_etaeta, Y_etaeta, X_xieta, Y_xieta

    def _compute_layer_thicknesses(self,):
        """Computes the boundary-normal layer thicknesses by compensating for
        the angle that the boundary and mesh lines meet. Computes data 
        everywhere, but only uses the results on the boudaries.
        """
        # axis 0 is in the xi direction and axis 1 is in the eta direction
        gradients_X_ax0, gradients_X_ax1 = np.gradient(self.X, edge_order=2)
        gradients_Y_ax0, gradients_Y_ax1 = np.gradient(self.Y, edge_order=2)

        # dot product between the wall-tangent vector and first-layer vector
        dot = gradients_X_ax0*gradients_X_ax1 + gradients_Y_ax0*gradients_Y_ax1
        dot /= np.sqrt(gradients_X_ax0**2 + gradients_Y_ax0**2)
        dot /= np.sqrt(gradients_X_ax1**2 + gradients_Y_ax1**2)

        # angle between the walls and mesh lines
        theta = np.empty_like(dot)
        theta[dot < 0] = np.arccos(dot[dot < 0]) - np.pi/2
        theta[dot > 0] = np.pi/2 - np.arccos(dot[dot > 0])

        # the naive distances are the pythagorean distances between points
        # on the boundary and first layer
        thick_naive_t = np.sqrt((self.X[:, -1] - self.X[:, -2])**2
                                + (self.Y[:, -1] - self.Y[:, -2])**2)
        thick_naive_b = np.sqrt((self.X[:, 0] - self.X[:, 1])**2
                                + (self.Y[:, 0] - self.Y[:, 1])**2)
        thick_naive_l = np.sqrt((self.X[0, :] - self.X[1, :])**2
                                + (self.Y[0, :] - self.Y[1, :])**2)
        thick_naive_r = np.sqrt((self.X[-1, :] - self.X[-2, :])**2
                                + (self.Y[-1, :] - self.Y[-2, :])**2)

        thick_t = thick_naive_t*np.cos(theta[self.top_indx])
        thick_b = thick_naive_b*np.cos(theta[self.bottom_indx])
        thick_l = thick_naive_l*np.cos(theta[self.left_indx])
        thick_r = thick_naive_r*np.cos(theta[self.right_indx])

        return thick_t, thick_b, thick_l, thick_r

    def _update_source_terms(self,):
        """These source terms are used to propogate the wall point distribution
        through the entire domain. The Psi term propogates the top and bottom
        wall point distributions while the Phi term propogates the left and 
        right wall point distributions.

        The source terms are computed in the computational domain and applied
        to their corresponding points in the physical domain. When a boundary
        has a very curved profile, it might squish or separate layers. To try
        and keep the spacing consistent, the source term strengths are 
        increased or decreased in the areas where the boundary profile is above
        or below an imaginary line that connects the two endpoints of that 
        side.

        The compensation method doesn't seem to be working perfectly since some
        profiles are seeing cells squished beyond the desired wall-normal 
        thickness.
        """
        if not self.layer_thickness_b and not self.layer_thickness_t:
            self.Phi = np.zeros_like(self.X[self.ij])
            self.Psi = np.zeros_like(self.X[self.ij])
            return

        first_derivs = self._compute_first_derivatives(interior=False)
        X_xi, Y_xi, X_eta, Y_eta = first_derivs
        second_derivs = self._compute_second_derivatives(interior=False)
        X_xixi, Y_xixi, X_etaeta, Y_etaeta, _, _ = second_derivs

        # to avoid dividing by 0, set those locations to 1 for the divide and
        # then return them (in phi and psi) to 0 afterwards
        # this only seems to happen when moving points on the boundaries to
        # enforce normality
        zeros_xi = np.isclose(X_xi, 0.) & np.isclose(Y_xi, 0.)
        zeros_eta = np.isclose(X_eta, 0.) & np.isclose(Y_eta, 0.)

        if np.any(zeros_xi):
            print("zero in both X_xi and Y_xi.")

        if np.any(zeros_eta):
            print("zero in both X_eta and Y_eta.")

        X_xi[zeros_xi] = Y_xi[zeros_xi] = 1.
        X_eta[zeros_eta] = Y_eta[zeros_eta] = 1.

        phi = -(X_xi*X_xixi + Y_xi*Y_xixi)/(X_xi**2 + Y_xi**2)
        psi = -(X_eta*X_etaeta + Y_eta*Y_etaeta)/(X_eta**2 + Y_eta**2)

        phi[zeros_xi] = psi[zeros_xi] = 0.
        phi[zeros_eta] = psi[zeros_eta] = 0.

        self.Phi = (self.Eta.T*phi[self.top_indx]
                    + (1-self.Eta).T*phi[self.bottom_indx]
                    )[self.ij].T
        self.Psi = (self.Xi*psi[self.left_indx]
                    + (1-self.Xi)*psi[self.right_indx]
                    )[self.ij]
        

    def _boundary_normal(self,
                         x_interior,
                         y_interior,
                         x_fine,
                         y_fine,
                         tree,
                         side):
        """For the given first-layer boundary points (i.e. the first interior 
        layer after) the boundary, this function will use the KDTree for that
        boundary and find the closest point on the boundary for each point. 

        To prevent points from collapsing (i.e. two mesh lines sharing the same 
        boundary point because it is the closest to both of them), the 
        `fix_duplicates` function loops through the points from the outside in.
        If any point is repeated or an earlier point shift results in the 
        points being out of order, then the point is updated based on the 
        adjacent point. For the middle point, both sides are checked.

        Once the duplicates have been fixed, the new boundary points are 
        returned.
        """
        N = x_interior.shape[0]
        if N == self.Nx-2:
            xy_interior = self.xy_interior_Nx
        elif N == self.Ny-2:
            xy_interior = self.xy_interior_Ny
        else:
            raise ValueError("MeshGenerator.py: Something went wrong with "
                             "the dimensions.")

        xy_interior[:, 0] = x_interior
        xy_interior[:, 1] = y_interior
        _, idxs = tree.query(xy_interior)       # returns distances and indices
        
        # to prevent points from moving too far, a limit of fine multipier-1
        # is imposed on how far a point can move in a given iteration (-1 to
        # avoid duplicates)
        original_idxs = self.original_idxs[side]
        max_allowed_move = self.fine_multiplier - 1
        
        # if a point is moved too far, it is pushed back to the maximum
        # the direction is distinguished to determine if the original index
        # should be added to or subtracted from to get to the location of the
        # maximum move
        moved_too_far_plus = (idxs - original_idxs) > max_allowed_move
        moved_too_far_minus = (original_idxs - idxs) > max_allowed_move
        idxs[moved_too_far_plus] = original_idxs[moved_too_far_plus] + max_allowed_move
        idxs[moved_too_far_minus] = original_idxs[moved_too_far_minus] - max_allowed_move

        def fix_duplicates(idxs):
            # Loops through half the points because both sides are done at the
            # same time.
            for i in range(1, N//2):
                # Checks from the left/bottom. If the point needs to be
                # updated, the index after the previous value is chosen.
                if idxs[i] <= idxs[i-1]:
                    idxs[i] = idxs[i-1] + 1
                # Checks from the right/top. If the point needs to be
                # updated, the index before the previous value is chosen.
                if idxs[-(i+1)] >= idxs[-i]:
                    idxs[-(i+1)] = idxs[-i] - 1
            
            # If there are an even number of points and the two middle points
            # have the same index after what was done above, then it is not
            # possible to remove the duplicates with this method.
            # If there are an odd number if points and the two points flanking
            # the middle point have the same index after what was done above,
            # then it is not possible to remove the duplicates this way.
            if ((N % 2 == 0 and idxs[N//2 - 1] == idxs[N//2]) or
                    (N % 2 != 0 and idxs[N//2 - 1] == idxs[N//2 + 1])):
                raise ValueError("Meshgenerator.py: Could not remove all "
                                 "duplicates for normality.")

            # If there are an odd number of points and the middle point is
            # equal to one of the flanking points (if we've gotten here, then
            # it cannot equal both because that was checked above), then we
            # will update the index using the same method as above. If the
            # flanking points are within 1 index of each other, then updating
            # will result in an overlap and removing all duplicates will not be
            # possible with this method.
            elif N % 2 != 0 and (idxs[N//2] == idxs[N//2 - 1]
                                 or idxs[N//2] == idxs[N//2 + 1]):
                if (idxs[N//2 - 1] == idxs[N//2]
                        and idxs[N//2 + 1] != idxs[N//2 - 1] + 1):
                    idxs[N//2] += 1
                    return
                elif (idxs[N//2 + 1] == idxs[N//2]
                      and idxs[N//2 + 1] - 1 != idxs[N//2 - 1]):
                    idxs[N//2] -= 1
                    return

                raise ValueError("Meshgenerator.py: Could not remove all "
                                 "duplicates for normality.")

        fix_duplicates(idxs)
        x = x_fine[idxs]
        y = y_fine[idxs]

        return x, y

    def _move_boundaries_for_normality(self,):
        """This function is an interface function for the `_boundary_normal` 
        function. For each side, it calls that function and passes the proper
        information, i.e. the x and y values of the first layer after the 
        boundary, the fine sampling of those boundaries, and the pre-computed
        KDTree for that boundary.
        """
        x_interior = self.X[self.ij]
        y_interior = self.Y[self.ij]

        # top
        self.X[self.i, -1], self.Y[self.i, -1] = self._boundary_normal(
            x_interior[self.top_indx],
            y_interior[self.top_indx],
            self.xfine_top,
            self.yfine_top,
            self.tree_t,
            "top")

        # bottom
        self.X[self.i, 0], self.Y[self.i, 0] = self._boundary_normal(
            x_interior[self.bottom_indx],
            y_interior[self.bottom_indx],
            self.xfine_bottom,
            self.yfine_bottom,
            self.tree_b,
            "bottom")

        # left
        self.X[0, self.j], self.Y[0, self.j] = self._boundary_normal(
            x_interior[self.left_indx],
            y_interior[self.left_indx],
            self.xfine_left,
            self.yfine_left,
            self.tree_l,
            "left")

        # right
        self.X[-1, self.j], self.Y[-1, self.j] = self._boundary_normal(
            x_interior[self.right_indx],
            y_interior[self.right_indx],
            self.xfine_right,
            self.yfine_right,
            self.tree_r,
            "right")

    def _jacobi(self,):
        """Jacobi iterative method solver function. This function will update 
        the interior points with the Jacobi iterative method by computing the 
        update for the interior X and Y points.

        WIP: Enforcing normality by including the dot product of the mesh lines
        and the boundary tangents, which should be 0 if they are perpendicular.
        """
        # first derivatives
        first_derivs = self._compute_first_derivatives(boundary=False)
        X_xi, Y_xi, X_eta, Y_eta = first_derivs

        # second derivatives
        #   xixi and etaeta are modified to remove xij, which is done
        #   because the equation is rearranged to solve for xij
        second_derivs = self._compute_second_derivatives(boundary=False,
                                                         modified=True)
        (X_xixi_m, Y_xixi_m,
         X_etaeta_m, Y_etaeta_m,
         X_xieta, Y_xieta) = second_derivs

        # general coefficients
        alpha = X_eta**2 + Y_eta**2
        beta = X_xi*X_eta + Y_xi*Y_eta
        gamma = X_xi**2 + Y_xi**2

        # coeff on ij
        #   this is the the inverse of the coefficient on the ij term, so it is
        #   multiplied through when solving for the ij term
        ijcoeff = 0.5/(self.Dxixi*alpha + self.Detaeta*gamma)

        # dot product normality enforcement (only top and bottom)
        self.dot = np.zeros_like(self.X[self.ij])
        if self.dot_product_normality:
            gridx_b = (self.X[:, 1] - self.X[:, 0])[1:-1]
            gridy_b = (self.Y[:, 1] - self.Y[:, 0])[1:-1]
            mag_b = np.sqrt(gridx_b**2 + gridy_b**2)
            gridx_b /= mag_b
            gridy_b /= mag_b

            dot_b = self.dx_b*gridx_b + self.dy_b*gridy_b

            gridx_t = (self.X[:, -2] - self.X[:, -1])[1:-1]
            gridy_t = (self.Y[:, -2] - self.Y[:, -1])[1:-1]
            mag_t = np.sqrt(gridx_t**2 + gridy_t**2)
            gridx_t /= mag_t
            gridy_t /= mag_t

            dot_t = self.dx_t*gridx_t + self.dy_t*gridy_t

            tau = self.normality_dist/5     # use 5 time constants for decay
            s_t = self.normality_strength*np.exp(-(1. - self.Eta[self.ij])/tau)
            s_b = self.normality_strength*np.exp(-self.Eta[self.ij]/tau)
            self.dot += s_t*dot_t[:, None]
            self.dot += s_b*dot_b[:, None]

        # jacobi
        self.X[self.ij] = ijcoeff*(alpha*(X_xixi_m + self.Phi*X_xi)
                                   - 2*beta*X_xieta
                                   + gamma*(X_etaeta_m + self.Psi*X_eta)
                                   - self.dot
                                   )
        self.Y[self.ij] = ijcoeff*(alpha*(Y_xixi_m + self.Phi*Y_xi)
                                   - 2*beta*Y_xieta
                                   + gamma*(Y_etaeta_m + self.Psi*Y_eta)
                                   - self.dot
                                   )

    def _krylov_step(self, xy):
        """This function computes the x and y PDE results for the Newton-Krylov
        method and saves the PDE results in a single numpy array that the 
        method is trying to optimize to a 0 matrix. This method makes use of 
        the class member X and Y arrays for the boundary points but the 
        iterated x and y arrays for the interior points.

        WIP: Enforcing normality by including the dot product of the mesh lines
        and the boundary tangents, which should be 0 if they are perpendicular.
        """
        x = xy[:, :self.Ny]
        y = xy[:, self.Ny:]

        for indx in [self.top_indx,
                     self.bottom_indx,
                     self.left_indx,
                     self.right_indx]:
            x[indx] = self.X[indx]
            y[indx] = self.Y[indx]

        # first derivatives
        X_xi = self.Dxi*(x[self.ip1, self.j] - x[self.im1, self.j])
        Y_xi = self.Dxi*(y[self.ip1, self.j] - y[self.im1, self.j])

        X_eta = self.Deta*(x[self.i, self.jp1] - x[self.i, self.jm1])
        Y_eta = self.Deta*(y[self.i, self.jp1] - y[self.i, self.jm1])

        # second derivatives
        X_xixi = self.Dxixi*(x[self.ip1, self.j]
                             - 2*x[self.ij]
                             + x[self.im1, self.j])
        Y_xixi = self.Dxixi*(y[self.ip1, self.j]
                             - 2*y[self.ij]
                             + y[self.im1, self.j])

        X_etaeta = self.Detaeta*(x[self.i, self.jp1]
                                 - 2*x[self.ij]
                                 + x[self.i, self.jm1])
        Y_etaeta = self.Detaeta*(y[self.i, self.jp1]
                                 - 2*y[self.ij]
                                 + y[self.i, self.jm1])

        X_xieta = self.Dxieta*(x[self.ip1, self.jp1]
                               - x[self.ip1, self.jm1]
                               - x[self.im1, self.jp1]
                               + x[self.im1, self.jm1])
        Y_xieta = self.Dxieta*(y[self.ip1, self.jp1]
                               - y[self.ip1, self.jm1]
                               - y[self.im1, self.jp1]
                               + y[self.im1, self.jm1])

        # general coefficients
        alpha = X_eta**2 + Y_eta**2
        beta = X_xi*X_eta + Y_xi*Y_eta
        gamma = X_xi**2 + Y_xi**2

        # dot product normality enforcement (only top and bottom)
        self.dot = np.zeros_like(x[self.ij])
        if self.dot_product_normality:
            gridx_b = (x[:, 1] - self.X[:, 0])[self.i]
            gridy_b = (y[:, 1] - self.Y[:, 0])[self.i]
            mag_b = np.sqrt(gridx_b**2 + gridy_b**2)
            gridx_b /= mag_b
            gridy_b /= mag_b

            dot_b = self.dx_b*gridx_b + self.dy_b*gridy_b

            gridx_t = (x[:, -2] - self.X[:, -1])[self.i]
            gridy_t = (y[:, -2] - self.Y[:, -1])[self.i]
            mag_t = np.sqrt(gridx_t**2 + gridy_t**2)
            gridx_t /= mag_t
            gridy_t /= mag_t

            dot_t = self.dx_t*gridx_t + self.dy_t*gridy_t

            tau = self.normality_dist/5     # use 5 time constants for decay
            s_t = self.normality_strength*np.exp(-(1. - self.Eta[self.ij])/tau)
            s_b = self.normality_strength*np.exp(-self.Eta[self.ij]/tau)
            self.dot += s_t*dot_t[:, None]
            self.dot += s_b*dot_b[:, None]

        # print(self.dot.min(), self.dot.max())

        PDE_x = (alpha*(X_xixi + self.Phi*X_xi)
                 - 2*beta*X_xieta
                 + gamma*(X_etaeta + self.Psi*X_eta)
                 ) - self.dot
        PDE_y = (alpha*(Y_xixi + self.Phi*Y_xi)
                 - 2*beta*Y_xieta
                 + gamma*(Y_etaeta + self.Psi*Y_eta)
                 ) - self.dot

        self.PDE_result[self.i, 1:self.Ny-1] = PDE_x
        self.PDE_result[self.i, self.Ny+1:-1] = PDE_y

        return self.PDE_result

    def _krylov(self,):
        """Newton-Krylov iterative method solver function. This function will 
        update the interior points with the Newton-Krylov method using the 
        SciPy Newton-Krylov optimizer. The optimizer makes us of the 
        `_krylov_step` function to evaluate the PDEs for optimization. Because
        a matrix is used to store the PDE results, the x and y points are 
        combined into a single matrix for the solver and then split up after 
        the solver call.
        """
        self.xy[:, :self.Ny] = self.X
        self.xy[:, self.Ny:] = self.Y

        # newton_krylov(self._krylov_step, self.xy)
        sol = root(self._krylov_step, self.xy, method="krylov")
        if not sol.success:
            text = ("Warning: Newton-Krylov solver failed. Here is the scipy "
                    f"root function return:\n{sol}.")
            format_dict = {"Warning":termfrmt.CBLINK+termfrmt.CRED,
                           "failed":termfrmt.CITALIC}
            self._formatted_print(text, format_dict)
            raise SystemExit

        self.X[self.ij] = sol.x[:, :self.Ny][self.ij]
        self.Y[self.ij] = sol.x[:, self.Ny:][self.ij]

    def _iterative_solve(self,):
        """This function will loop up to the maximum number of iterations and 
        update the interior using the chosen solver. At the beginning of each 
        step, the old points are saved and then after the iterative step, the 
        amount each point has moved (Pythagorean distance) is computed. The 
        maxmimum move gives a metric for convergence, where the solution is 
        converged if the max move is within the set tolerance.

        If the user turned on normality using the moving boundary points 
        method (chosen by setting `moving_boundaries=True`), then it will start
        moving the boundary after 100x the tolerance or 20% of the maxiter has
        been reached, whichever is satisified first. This is to allow some 
        initial convergence before the boundary points are shifted. It will 
        then update the boundary points every 100 iterations. When on, the 
        convergence cannot be satisfied until the boundary started to be moved.
        """
        tic = time.perf_counter()
        self._update_source_terms()
        move_boundaries = False
        for n_iter in range(1, self.maxiter+1):
            X_old = self.X.copy()
            Y_old = self.Y.copy()

            if self.dot_product_normality:
                self.dx_b = np.diff(self.X[self.bottom_indx])[:-1]
                self.dy_b = np.diff(self.Y[self.bottom_indx])[:-1]
                norm_b = np.sqrt(self.dx_b**2 + self.dy_b**2)
                self.dx_b /= norm_b
                self.dy_b /= norm_b

                self.dx_t = np.diff(self.X[self.top_indx])[:-1]
                self.dy_t = np.diff(self.Y[self.top_indx])[:-1]
                norm_t = np.sqrt(self.dx_t**2 + self.dy_t**2)
                self.dx_t /= norm_t
                self.dy_t /= norm_t

            # move boundaries so the normal condition is satisfied
            if move_boundaries and n_iter % self.move_frequency == 0:
                self._move_boundaries_for_normality()

                # source terms are only updated if the boundary has changed
                self._update_source_terms()

            self._solver()

            # use the point movement as a convergence proxy
            max_move = np.sqrt((self.X[self.ij]
                                - X_old[self.ij])**2
                               + (self.Y[self.ij]
                                  - Y_old[self.ij])**2).max()

            if self.verbose and (n_iter % self.verbose_frequency == 0):
                if n_iter == 0:
                    print(f"{'n':<6} max move")
                print(f"{n_iter:<6} {max_move:.10f}")

            # exit conditions
            if ((not self.moving_boundaries or move_boundaries)
                    and max_move <= self.tol):
                break

            # if moving boundaries, only start after partial convergence
            if (self.moving_boundaries
                and not move_boundaries
                    and (max_move <= self.tol*100
                         or n_iter >= 0.2*self.maxiter)):
                if self.verbose:
                    text = "--> Starting to move boundaries."
                    format_dict = {"move boundaries":termfrmt.CITALIC}
                    self._formatted_print(text, format_dict)
                move_boundaries = True
        else:
            text = ("Warning: Solution did not coverge.")
            format_dict = {"Warning":termfrmt.CBLINK+termfrmt.CRED,
                           "failed":termfrmt.CITALIC}
            self._formatted_print(text, format_dict)
            if self.moving_boundaries:
                text = ("   Convergence may have been prevented by boundary "
                        "points being moved back and forth one position when "
                        "moving boundaries is being used. An indication of "
                        "this is the 'max move' value fluctuates around the "
                        "'minimum fine boundary distance' reported at the "
                        "start. If this was the cause, then the mesh is "
                        "probably good to use.")
                format_dict = {"max move":termfrmt.CITALIC,
                               "minimum fine boundary distance":termfrmt.CITALIC}
                self._formatted_print(text, format_dict)

        toc = time.perf_counter()
        if self.verbose:
            if n_iter != self.maxiter:
                print(f"{n_iter:<6} {max_move:.10f}")
            X_xi, Y_xi, X_eta, Y_eta = self._compute_first_derivatives()
            Jac = X_xi*Y_eta - X_eta*Y_xi
            text = " Statistics ".center(40, "~")
            format_dict = {"Statistics":termfrmt.CITALIC}
            self._formatted_print(text, format_dict)
            print(f"Time elapsed: {toc - tic: 0.4f}s")
            print(f"error: {max_move}")
            print(f"det(Jac) > 0: {np.all(Jac > 0)}")

            temp = self._compute_layer_thicknesses()
            thick_t, thick_b, thick_l, thick_r = temp
            print("Layer Thicknesses")
            print(f"\t{'min':>12}{'max':>8}")
            print(f"\t{'top:':<8} {thick_t.min():.4f}  {thick_t.max():.4f}")
            print(f"\t{'bottom:':<8} {thick_b.min():.4f}  {thick_b.max():.4f}")
            print(f"\t{'left:':<8} {thick_l.min():.4f}  {thick_l.max():.4f}")
            print(f"\t{'right:':<8} {thick_r.min():.4f}  {thick_r.max():.4f}")
            
    def _formatted_print(self, text, format_dict):
        formatted_text = text
        for toformat, formatting in format_dict.items():
            formatted = f"{formatting}{toformat}{termfrmt.CEND}"
            formatted_text = formatted_text.replace(toformat, formatted)
        print(formatted_text)

    def _grid_plot(self, **kwargs):
        """Plots the grid lines"""
        fig, ax = plt.subplots(figsize=kwargs.get("figsize", None))
        ax.plot(self.X, self.Y, color="k", lw=kwargs.get("lw", 0.25))
        ax.plot(self.X.T, self.Y.T, color="k", lw=kwargs.get("lw", 0.25))
        ax.set_aspect(1)
        ax.set_xlabel(kwargs.get("xlabel", "$x$"))
        ax.set_ylabel(kwargs.get("ylabel", "$y$"))

        return fig, ax

    def _jacobian_plot(self, **kwargs):
        """Plots the Jacobian of each point. If `plot_surface=True`, then it
        will use a convolution to average the four corners and get a value for
        the center. It does not perform a weighted average based on the shape.
        """
        normalize = kwargs.get("normalize", False)
        plot_surface = kwargs.get("plot_surface", False)

        first_derivs = self._compute_first_derivatives()
        X_xi, Y_xi, X_eta, Y_eta = first_derivs
        Jac = X_xi*Y_eta - X_eta*Y_xi
        if normalize:
            Jac /= np.abs(Jac).max()

        if plot_surface:
            fig, ax = plt.subplots(subplot_kw={"projection": "3d"},
                                   figsize=kwargs.get("figsize", None))
            ax.plot_surface(self.X, self.Y, Jac)
        else:
            fig, ax = plt.subplots(figsize=kwargs.get("figsize", None))
            jac_plot = ax.scatter(self.X, self.Y, c=Jac,
                                  s=500/max(self.Nx, self.Ny))
            cbar = fig.colorbar(jac_plot)
            if normalize:
                cbar.mappable.set_clim(vmin=-1, vmax=1)
            ax.set_aspect(1)

        if normalize:
            ax.set_title("Jacobian Determinant (Normalized)")
        else:
            ax.set_title("Jacobian Determinant")

        if kwargs.get("return_jac", False):
            return fig, ax, Jac
        return fig, ax

    def _gradient_plot(self, **kwargs):
        """Plots the four gradients of the phyiscal to computational 
        coordinates.
        """
        first_derivs = self._compute_first_derivatives(convolve=True)
        X_xi, Y_xi, X_eta, Y_eta = first_derivs

        normalize = kwargs.get("normalize", False)
        if normalize:
            X_xi /= np.abs(X_xi).max()
            Y_xi /= np.abs(Y_xi).max()
            X_eta /= np.abs(X_eta).max()
            Y_eta /= np.abs(Y_eta).max()

        fig, axes = plt.subplots(2, 2, sharex=True, sharey=True,
                                 figsize=kwargs.get("figsize", None))
        axes = axes.flatten()
        partials = [X_xi, X_eta, Y_xi, Y_eta]
        titles = [r"$\partial x/\partial \xi$",
                  r"$\partial x/\partial \eta$",
                  r"$\partial y/\partial \xi$",
                  r"$\partial y/\partial \eta$"]
        vmin = np.min(partials)
        vmax = np.max(partials)
        for ax, partial, title in zip(axes, partials, titles):
            partial_plot = ax.pcolormesh(self.X, self.Y, partial,
                                         vmin=vmin, vmax=vmax)
            ax.set_title(title)
            ax.set_aspect(1)
        axes[0].set_ylabel("$y$")
        axes[2].set_ylabel("$y$")
        axes[2].set_xlabel("$x$")
        axes[3].set_xlabel("$x$")
        fig.tight_layout()

        fig.subplots_adjust(top=0.9)
        if normalize:
            fig.suptitle("Partial Derivatives (Normalized)", y=0.98)
            cbar = fig.colorbar(partial_plot, ax=axes.tolist())
            cbar.mappable.set_clim(vmin=-1, vmax=1)
        else:
            fig.suptitle("Partial Derivatives", y=0.98)
            fig.colorbar(partial_plot, ax=axes.tolist())

        return fig, ax

    def _layer_thickness_plot(self, **kwargs):
        """Plots the layer thicknesses which are computed using the Pythagorean
        distance between points. Plots both the left/right and top/bottom 
        thicknesses.
        """
        fig, axes = plt.subplots(2, 2, figsize=kwargs.get("figsize", None))
        axes = axes.flatten().tolist()
        sides = [self.X[self.top_indx],
                 self.X[self.bottom_indx],
                 self.Y[self.left_indx],
                 self.Y[self.right_indx]]
        thicknesses = self._compute_layer_thicknesses()
        titles = ["Top"
                  f"\n(min={thicknesses[0].min():.4f},"
                  f" max={thicknesses[0].max():.4f})",
                  "Bottom"
                  f"\n(min={thicknesses[1].min():.4f},"
                  f" max={thicknesses[1].max():.4f})",
                  "Left"
                  f"\n(min={thicknesses[2].min():.4f},"
                  f" max={thicknesses[2].max():.4f})",
                  "Right"
                  f"\n(min={thicknesses[3].min():.4f},"
                  f" max={thicknesses[3].max():.4f})",]
        for ax, side, thickness, title in zip(axes, sides, thicknesses, titles):
            ax.plot(side, thickness)
            ax.set_title(title)
            ax.set_ylabel("thickness")

        axes[0].set_xlabel("$x$")
        axes[1].set_xlabel("$x$")
        axes[2].set_xlabel("$y$")
        axes[3].set_xlabel("$y$")

        fig.suptitle("Layer Thicknesses", y=0.93)
        fig.tight_layout()

        return fig, ax

class termfrmt:
    CEND      = "\33[0m"
    CBOLD     = "\33[1m"
    CITALIC   = "\33[3m"
    CURL      = "\33[4m"
    CBLINK    = "\33[5m"
    CBLINK2   = "\33[6m"
    CSELECTED = "\33[7m"
    CIBOLD    = CBOLD + CITALIC
    
    CBLACK  = "\33[30m"
    CRED    = "\33[31m"
    CGREEN  = "\33[32m"
    CYELLOW = "\33[33m"
    CBLUE   = "\33[34m"
    CVIOLET = "\33[35m"
    CBEIGE  = "\33[36m"
    CWHITE  = "\33[37m"

    CBLACKBG  = "\33[40m"
    CREDBG    = "\33[41m"
    CGREENBG  = "\33[42m"
    CYELLOWBG = "\33[43m"
    CBLUEBG   = "\33[44m"
    CVIOLETBG = "\33[45m"
    CBEIGEBG  = "\33[46m"
    CWHITEBG  = "\33[47m"
    
    CGREY    = "\33[90m"
    CRED2    = "\33[91m"
    CGREEN2  = "\33[92m"
    CYELLOW2 = "\33[93m"
    CBLUE2   = "\33[94m"
    CVIOLET2 = "\33[95m"
    CBEIGE2  = "\33[96m"
    CWHITE2  = "\33[97m"
    
    CGREYBG    = "\33[100m"
    CREDBG2    = "\33[101m"
    CGREENBG2  = "\33[102m"
    CYELLOWBG2 = "\33[103m"
    CBLUEBG2   = "\33[104m"
    CVIOLETBG2 = "\33[105m"
    CBEIGEBG2  = "\33[106m"
    CWHITEBG2  = "\33[107m"